<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog T√©cnico - Estructura de Datos: Grafos</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <nav class="navbar">
            <div class="container">
                <h1 class="logo">üìö Blog T√©cnico</h1>
                <ul class="nav-links">
                    <li><a href="#inicio" class="nav-link active" onclick="mostrarSeccion('inicio')">Inicio</a></li>
                    <li><a href="#post1" class="nav-link" onclick="mostrarSeccion('post1')">Post 1</a></li>
                    <li><a href="#post2" class="nav-link" onclick="mostrarSeccion('post2')">Post 2</a></li>
                    <li><a href="#post3" class="nav-link" onclick="mostrarSeccion('post3')">Post 3</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <main class="container">
        <!-- SECCI√ìN INICIO -->
        <section id="inicio" class="seccion activa">
            <div class="hero">
                <h1>Estructura de Datos: Grafos</h1>
                <p class="subtitulo">Explora la teor√≠a, representaci√≥n y algoritmos fundamentales de esta estructura de datos esencial</p>
            </div>

            <div class="posts-grid">
                <article class="post-preview" onclick="mostrarSeccion('post1')">
                    <h3>üìñ Post #1: Introducci√≥n a los Grafos</h3>
                    <p>Descubre qu√© son los nodos, aristas y los diferentes tipos de grafos que existen.</p>
                    <button class="btn-leer">Leer m√°s ‚Üí</button>
                </article>

                <article class="post-preview" onclick="mostrarSeccion('post2')">
                    <h3>üóÇÔ∏è Post #2: Representaci√≥n de Grafos</h3>
                    <p>Aprende las dos formas principales de representar grafos en memoria.</p>
                    <button class="btn-leer">Leer m√°s ‚Üí</button>
                </article>

                <article class="post-preview" onclick="mostrarSeccion('post3')">
                    <h3>üîç Post #3: Algoritmos de Recorrido</h3>
                    <p>Domina BFS y DFS, los algoritmos esenciales para recorrer grafos.</p>
                    <button class="btn-leer">Leer m√°s ‚Üí</button>
                </article>
            </div>
        </section>

        <!-- POST #1: INTRODUCCI√ìN A GRAFOS -->
        <section id="post1" class="seccion">
            <article class="post-completo">
                <div class="post-header">
                    <h1>Post #1: Introducci√≥n a los Grafos: Nodos, Aristas y Tipos</h1>
                    <p class="fecha">Publicado: 2 de diciembre de 2025</p>
                </div>

                <h2>¬øQu√© es un Grafo?</h2>
                <p>
                    Un <strong>grafo</strong> es una estructura de datos abstracta que representa un conjunto de objetos 
                    (llamados <strong>v√©rtices</strong> o <strong>nodos</strong>) conectados entre s√≠ mediante conexiones 
                    (llamadas <strong>aristas</strong> o <strong>ejes</strong>). Los grafos son fundamentales en la ciencia 
                    de la computaci√≥n y se utilizan para modelar relaciones entre entidades.
                </p>

                <h2>Conceptos Clave</h2>
                
                <h3>1. V√©rtices o Nodos</h3>
                <p>
                    Un <strong>v√©rtice</strong> es una entidad o punto fundamental en un grafo. Cada v√©rtice puede 
                    representar cualquier cosa: una ciudad, una persona, una computadora en una red, etc.
                </p>

                <h3>2. Aristas o Ejes</h3>
                <p>
                    Una <strong>arista</strong> es una conexi√≥n entre dos v√©rtices. Representa una relaci√≥n o conexi√≥n 
                    entre las entidades representadas por los v√©rtices.
                </p>

                <h3>3. Grado de un V√©rtice</h3>
                <p>
                    El <strong>grado</strong> de un v√©rtice es el n√∫mero de aristas conectadas a ese v√©rtice. En grafos 
                    dirigidos, distinguimos entre <strong>grado de entrada</strong> (aristas que entran) y 
                    <strong>grado de salida</strong> (aristas que salen).
                </p>

                <h2>Tipos de Grafos</h2>

                <h3>1. Grafos No Dirigidos</h3>
                <p>
                    En un grafo <strong>no dirigido</strong>, las aristas no tienen direcci√≥n. La conexi√≥n entre dos 
                    v√©rtices es bidireccional. Si existe una arista entre A y B, tambi√©n existe entre B y A.
                </p>
                <p><strong>Ejemplo:</strong> Una red de amigos en redes sociales.</p>

                <h3>2. Grafos Dirigidos (D√≠grafos)</h3>
                <p>
                    En un grafo <strong>dirigido</strong>, las aristas tienen direcci√≥n, representada por una flecha. 
                    Una arista va de un v√©rtice a otro, pero no necesariamente en ambas direcciones.
                </p>
                <p><strong>Ejemplo:</strong> Un grafo de seguidores en Twitter/X.</p>

                <h3>3. Grafos Ponderados</h3>
                <p>
                    Un grafo <strong>ponderado</strong> es aquel en el que cada arista tiene asociado un valor num√©rico 
                    llamado <strong>peso</strong>. Este peso puede representar distancia, costo, tiempo, etc.
                </p>
                <p><strong>Ejemplo:</strong> Un mapa de ciudades donde el peso es la distancia en kil√≥metros.</p>

                <h2>Ejemplo Visual: Grafo No Dirigido con 5 Nodos</h2>
                <p>A continuaci√≥n se muestra un grafo no dirigido con 5 nodos y sus conexiones:</p>
                
                <div class="visualizador-grafo">
                    <canvas id="canvasGrafo1"></canvas>
                </div>

                <p class="explicacion-visual">
                    <strong>Descripci√≥n:</strong> El grafo anterior contiene 5 nodos (A, B, C, D, E) conectados de la siguiente forma:
                    A-B, A-C, B-C, B-D, C-E, D-E. Como es no dirigido, cada arista funciona en ambas direcciones.
                </p>

                <h2>Conclusi√≥n</h2>
                <p>
                    Los grafos son estructuras vers√°tiles que permiten modelar relaciones complejas. Entender los conceptos 
                    b√°sicos de nodos, aristas y tipos de grafos es fundamental para aplicar algoritmos m√°s avanzados.
                </p>
            </article>
        </section>

        <!-- POST #2: REPRESENTACI√ìN DE GRAFOS -->
        <section id="post2" class="seccion">
            <article class="post-completo">
                <div class="post-header">
                    <h1>Post #2: Representaci√≥n de Grafos</h1>
                    <p class="fecha">Publicado: 2 de diciembre de 2025</p>
                </div>

                <h2>Introducci√≥n</h2>
                <p>
                    Existen dos formas principales de representar un grafo en la memoria de una computadora. Cada una tiene 
                    ventajas y desventajas dependiendo del tipo de operaciones que necesitemos realizar.
                </p>

                <h2>1. Lista de Adyacencia</h2>
                
                <h3>¬øQu√© es?</h3>
                <p>
                    Una <strong>lista de adyacencia</strong> es una representaci√≥n en la que cada v√©rtice tiene asociada una 
                    lista con todos los v√©rtices adyacentes a √©l (los v√©rtices con los que est√° conectado).
                </p>

                <h3>Ventajas</h3>
                <ul>
                    <li><strong>Eficiencia de espacio:</strong> Ideal para grafos dispersos (con pocas aristas) ya que solo 
                    almacena las aristas que existen.</li>
                    <li>El espacio usado es O(V + E), donde V es el n√∫mero de v√©rtices y E el de aristas.</li>
                    <li>Iteraci√≥n r√°pida sobre los vecinos de un nodo.</li>
                </ul>

                <h3>Desventajas</h3>
                <ul>
                    <li>Verificar si existe una arista entre dos v√©rtices espec√≠ficos puede ser lento O(grado del v√©rtice).</li>
                    <li>M√°s compleja de implementar que una matriz.</li>
                </ul>

                <h3>Representaci√≥n</h3>
                <pre><code>Grafo: A-B, A-C, B-C, B-D

Estructura:
A: [B, C]
B: [A, C, D]
C: [A, B]
D: [B]</code></pre>

                <h2>2. Matriz de Adyacencia</h2>
                
                <h3>¬øQu√© es?</h3>
                <p>
                    Una <strong>matriz de adyacencia</strong> es una matriz cuadrada M donde M[i][j] representa si existe 
                    una arista entre el v√©rtice i y el v√©rtice j. El valor es 1 si existe la arista, 0 si no existe. 
                    En grafos ponderados, se almacena el peso de la arista.
                </p>

                <h3>Ventajas</h3>
                <ul>
                    <li><strong>Eficiencia de tiempo:</strong> Verificar si existe una arista entre dos v√©rtices es O(1).</li>
                    <li>Estructura simple de implementar y usar.</li>
                    <li>Ideal para grafos densos (con muchas aristas).</li>
                </ul>

                <h3>Desventajas</h3>
                <ul>
                    <li><strong>Eficiencia de espacio:</strong> Ocupa O(V¬≤) de memoria, incluso si hay pocas aristas.</li>
                    <li>Ineficiente para grafos dispersos.</li>
                </ul>

                <h3>Representaci√≥n</h3>
                <pre><code>Grafo: A-B, A-C, B-C, B-D (no dirigido)

Matriz de Adyacencia:
    A  B  C  D
A [ 0  1  1  0 ]
B [ 1  0  1  1 ]
C [ 1  1  0  0 ]
D [ 0  1  0  0 ]</code></pre>

                <h2>Comparaci√≥n Visual</h2>
                <p>A continuaci√≥n se muestra el mismo grafo representado de ambas formas:</p>
                
                <div class="comparacion-representaciones">
                    <div class="representacion">
                        <h3>Grafo Visual</h3>
                        <canvas id="canvasGrafo2"></canvas>
                    </div>
                    <div class="representacion">
                        <h3>Lista de Adyacencia</h3>
                        <pre id="listaAdy"><code>A: [B, C]
B: [A, C, D]
C: [A, B]
D: [B]</code></pre>
                    </div>
                    <div class="representacion">
                        <h3>Matriz de Adyacencia</h3>
                        <table class="matriz-table">
                            <tr>
                                <td></td>
                                <td><strong>A</strong></td>
                                <td><strong>B</strong></td>
                                <td><strong>C</strong></td>
                                <td><strong>D</strong></td>
                            </tr>
                            <tr>
                                <td><strong>A</strong></td>
                                <td>0</td>
                                <td>1</td>
                                <td>1</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td><strong>B</strong></td>
                                <td>1</td>
                                <td>0</td>
                                <td>1</td>
                                <td>1</td>
                            </tr>
                            <tr>
                                <td><strong>C</strong></td>
                                <td>1</td>
                                <td>1</td>
                                <td>0</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td><strong>D</strong></td>
                                <td>0</td>
                                <td>1</td>
                                <td>0</td>
                                <td>0</td>
                            </tr>
                        </table>
                    </div>
                </div>

                <h2>¬øCu√°l Usar?</h2>
                <p>
                    <strong>Use Lista de Adyacencia cuando:</strong>
                </p>
                <ul>
                    <li>El grafo es disperso (pocas aristas respecto a v√©rtices).</li>
                    <li>Necesita iterar sobre vecinos frecuentemente.</li>
                    <li>La memoria es una restricci√≥n.</li>
                </ul>

                <p>
                    <strong>Use Matriz de Adyacencia cuando:</strong>
                </p>
                <ul>
                    <li>El grafo es denso (muchas aristas).</li>
                    <li>Necesita consultas r√°pidas sobre existencia de aristas.</li>
                    <li>La memoria no es una restricci√≥n.</li>
                </ul>

                <h2>Conclusi√≥n</h2>
                <p>
                    La elecci√≥n de la representaci√≥n depende del tipo de operaciones que realizar√° y de las caracter√≠sticas 
                    del grafo. Ambas representaciones son v√°lidas y se usan frecuentemente en diferentes contextos.
                </p>
            </article>
        </section>

        <!-- POST #3: ALGORITMOS DE RECORRIDO -->
        <section id="post3" class="seccion">
            <article class="post-completo">
                <div class="post-header">
                    <h1>Post #3: Algoritmos Fundamentales de Recorrido</h1>
                    <p class="fecha">Publicado: 2 de diciembre de 2025</p>
                </div>

                <h2>Introducci√≥n</h2>
                <p>
                    Los algoritmos de recorrido son fundamentales para trabajar con grafos. Permiten explorar todos los 
                    nodos de un grafo de manera sistem√°tica. Los dos m√°s importantes son:
                </p>
                <ul>
                    <li><strong>BFS (Breadth-First Search):</strong> B√∫squeda en Amplitud</li>
                    <li><strong>DFS (Depth-First Search):</strong> B√∫squeda en Profundidad</li>
                </ul>

                <h2>1. B√∫squeda en Amplitud (BFS)</h2>

                <h3>¬øQu√© es?</h3>
                <p>
                    BFS es un algoritmo que explora un grafo nivel por nivel. Comienza en un nodo inicial y visita todos 
                    los nodos adyacentes antes de pasar al siguiente nivel. Utiliza una <strong>cola (queue)</strong> para 
                    mantener el orden de exploraci√≥n.
                </p>

                <h3>Caracter√≠sticas</h3>
                <ul>
                    <li>Explora por niveles (amplitud).</li>
                    <li>Usa una estructura de datos <strong>Cola (FIFO)</strong>.</li>
                    <li>Complejidad temporal: O(V + E), donde V es v√©rtices y E aristas.</li>
                    <li>Complejidad espacial: O(V).</li>
                </ul>

                <h3>Aplicaciones</h3>
                <ul>
                    <li>Encontrar el camino m√°s corto entre dos nodos.</li>
                    <li>Detectar ciclos en grafos no dirigidos.</li>
                    <li>B√∫squeda por niveles o exploraci√≥n de redes.</li>
                    <li>An√°lisis de conectividad.</li>
                </ul>

                <h3>Pseudoc√≥digo</h3>
                <pre><code>Algoritmo BFS(grafo, inicio):
    cola = Cola vac√≠a
    visitados = conjunto vac√≠o
    
    cola.encolar(inicio)
    visitados.agregar(inicio)
    
    mientras cola no est√© vac√≠a:
        nodo = cola.desencolar()
        procesar(nodo)
        
        para cada vecino de nodo:
            si vecino no est√° visitado:
                visitados.agregar(vecino)
                cola.encolar(vecino)</code></pre>

                <h3>Ejemplo Visual - BFS</h3>
                <div class="visualizador-algoritmo">
                    <canvas id="canvasBFS"></canvas>
                    <p class="leyenda-bfs">Orden de visitaci√≥n: A ‚Üí B, C ‚Üí D, E ‚Üí F, G, H, I</p>
                </div>

                <h2>2. B√∫squeda en Profundidad (DFS)</h2>

                <h3>¬øQu√© es?</h3>
                <p>
                    DFS es un algoritmo que explora un grafo siguiendo una rama lo m√°s profundamente posible antes de 
                    retroceder. Utiliza una <strong>pila (stack)</strong> o recursi√≥n para mantener el orden de exploraci√≥n.
                </p>

                <h3>Caracter√≠sticas</h3>
                <ul>
                    <li>Explora verticalmente (profundidad).</li>
                    <li>Usa una estructura de datos <strong>Pila (LIFO)</strong> o recursi√≥n.</li>
                    <li>Complejidad temporal: O(V + E).</li>
                    <li>Complejidad espacial: O(V) (por la pila de recursi√≥n).</li>
                </ul>

                <h3>Aplicaciones</h3>
                <ul>
                    <li>Detectar ciclos en grafos dirigidos.</li>
                    <li>Ordenamiento topol√≥gico.</li>
                    <li>B√∫squeda de componentes fuertemente conexas.</li>
                    <li>Resoluci√≥n de problemas de laberintos.</li>
                </ul>

                <h3>Pseudoc√≥digo</h3>
                <pre><code>Algoritmo DFS(grafo, inicio):
    visitados = conjunto vac√≠o
    
    Funci√≥n DFS_Recursivo(nodo):
        visitados.agregar(nodo)
        procesar(nodo)
        
        para cada vecino de nodo:
            si vecino no est√° visitado:
                DFS_Recursivo(vecino)
    
    DFS_Recursivo(inicio)</code></pre>

                <h3>Ejemplo Visual - DFS</h3>
                <div class="visualizador-algoritmo">
                    <canvas id="canvasDFS"></canvas>
                    <p class="leyenda-dfs">Orden de visitaci√≥n: A ‚Üí B ‚Üí D ‚Üí C ‚Üí E ‚Üí F ‚Üí G ‚Üí H ‚Üí I</p>
                </div>

                <h2>Comparaci√≥n: BFS vs DFS</h2>
                <table class="comparacion-table">
                    <tr>
                        <th>Aspecto</th>
                        <th>BFS</th>
                        <th>DFS</th>
                    </tr>
                    <tr>
                        <td><strong>Estrategia</strong></td>
                        <td>Por amplitud (nivel a nivel)</td>
                        <td>Por profundidad (rama completa)</td>
                    </tr>
                    <tr>
                        <td><strong>Estructura de datos</strong></td>
                        <td>Cola (FIFO)</td>
                        <td>Pila (LIFO) / Recursi√≥n</td>
                    </tr>
                    <tr>
                        <td><strong>Complejidad temporal</strong></td>
                        <td>O(V + E)</td>
                        <td>O(V + E)</td>
                    </tr>
                    <tr>
                        <td><strong>Camino m√°s corto</strong></td>
                        <td>‚úì S√≠ (en grafos sin pesos)</td>
                        <td>‚úó No garantizado</td>
                    </tr>
                    <tr>
                        <td><strong>Uso</strong></td>
                        <td>Redes, conectividad</td>
                        <td>Ciclos, topolog√≠a</td>
                    </tr>
                </table>

                <h2>Conclusi√≥n</h2>
                <p>
                    BFS y DFS son algoritmos complementarios que se utilizan en diferentes contextos. BFS es ideal para 
                    encontrar caminos m√°s cortos, mientras que DFS es mejor para problemas que requieren exploraci√≥n completa 
                    en profundidad. Ambos tienen la misma complejidad temporal pero se diferencia en el orden de visitaci√≥n.
                </p>
            </article>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Blog T√©cnico - Estructura de Datos: Grafos. Desarrollado con HTML, CSS y JavaScript.</p>
        <p>Repositorio: <a href="https://github.com/JavierTG1975/Blogtecnico" target="_blank">GitHub - Blogtecnico</a></p>
    </footer>

    <script src="script.js"></script>
</body>
</html>
